<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Visualise/Common.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE NoMonomorphismRestriction #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE FlexibleContexts          #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE FlexibleInstances #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE UndecidableInstances #-}</span>
<a name="line-5"></a><span class='hs-comment'>{-# LANGUAGE TypeFamilies #-}</span>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE TemplateHaskell #-}</span>
<a name="line-7"></a>
<a name="line-8"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-9"></a><span class='hs-comment'>-- |</span>
<a name="line-10"></a><span class='hs-comment'>-- Module: Visualise.Common</span>
<a name="line-11"></a><span class='hs-comment'>-- Copyright : (c) Samuel Prescott 2018</span>
<a name="line-12"></a><span class='hs-comment'>-- </span>
<a name="line-13"></a><span class='hs-comment'>-- Provides common types, typeclasses and functions used by the various drawing</span>
<a name="line-14"></a><span class='hs-comment'>-- modules.</span>
<a name="line-15"></a><span class='hs-comment'>--</span>
<a name="line-16"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-17"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Visualise</span><span class='hs-varop'>.</span><span class='hs-conid'>Common</span> <span class='hs-layout'>(</span>
<a name="line-18"></a>    <span class='hs-comment'>-- * The 'Settings' type used by most drawing modules to customise the drawing of a graph.</span>
<a name="line-19"></a>    <span class='hs-conid'>Settings</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> 
<a name="line-20"></a>
<a name="line-21"></a>    <span class='hs-comment'>-- * The 'Node' type which is used by the drawing modules to represent a vertex, containing a 'String' representation and a &lt;https://hackage.haskell.org/package/diagrams Diagram&gt; representation.</span>
<a name="line-22"></a>    <span class='hs-conid'>Node</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> 
<a name="line-23"></a>
<a name="line-24"></a>    <span class='hs-comment'>-- * The 'ProcessedGraph' type which is used by 'getVertices' to represent a graph that has been folded through, with a list of vertices and a list of conenctions.</span>
<a name="line-25"></a>    <span class='hs-conid'>ProcessedGraph</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span> 
<a name="line-26"></a>
<a name="line-27"></a>    <span class='hs-comment'>-- * The 'Boolean' type 'Directed' which determines whether a graph is directed/has arrows on connections.</span>
<a name="line-28"></a>    <span class='hs-conid'>Directed</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>..</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span>
<a name="line-29"></a>
<a name="line-30"></a>    <span class='hs-comment'>-- * An array of tuples representing connections in a graph.</span>
<a name="line-31"></a>    <span class='hs-conid'>ConnectList</span><span class='hs-layout'>,</span>
<a name="line-32"></a>
<a name="line-33"></a>    <span class='hs-comment'>-- * The 'Draw' TypeClass which determines how to draw a 'Node' using the function 'draw'.</span>
<a name="line-34"></a>    <span class='hs-conid'>Draw</span><span class='hs-layout'>,</span> <span class='hs-varid'>draw</span><span class='hs-layout'>,</span>
<a name="line-35"></a>
<a name="line-36"></a>    <span class='hs-comment'>-- * The 'Countable' TypeClass which determines how to count the number of vertices in a graph/graph of graphs using the function 'count'.</span>
<a name="line-37"></a>    <span class='hs-conid'>Countable</span><span class='hs-layout'>,</span> <span class='hs-varid'>count</span><span class='hs-layout'>,</span>
<a name="line-38"></a>
<a name="line-39"></a>    <span class='hs-comment'>-- * The default vertex-drawing functions.</span>
<a name="line-40"></a>    <span class='hs-varid'>drawDefaultNode</span><span class='hs-layout'>,</span> <span class='hs-varid'>drawDefaultNodeWithSize</span><span class='hs-layout'>,</span> <span class='hs-varid'>drawDefaultEmptyNode</span><span class='hs-layout'>,</span> <span class='hs-varid'>drawNodeWithEmptyFlag</span><span class='hs-layout'>,</span>
<a name="line-41"></a>
<a name="line-42"></a>    <span class='hs-comment'>-- * Gets a 'ProcessedGraph' containing a graph's vertices and connections, a wrapper for 'namesAndConnections'.</span>
<a name="line-43"></a>    <span class='hs-varid'>getVertices</span><span class='hs-layout'>,</span> 
<a name="line-44"></a>
<a name="line-45"></a>    <span class='hs-comment'>-- * Gets a 'ProcessedGraph' containing a graph's vertices and connections, recursive requiring a counter string.</span>
<a name="line-46"></a>    <span class='hs-varid'>namesAndConnections</span><span class='hs-layout'>,</span> 
<a name="line-47"></a>
<a name="line-48"></a>    <span class='hs-comment'>-- * Gets the vertices connected from and to a specified vertex.</span>
<a name="line-49"></a>    <span class='hs-varid'>connectedFrom</span><span class='hs-layout'>,</span> <span class='hs-varid'>connectedTo</span><span class='hs-layout'>,</span> 
<a name="line-50"></a>
<a name="line-51"></a>    <span class='hs-comment'>-- * Used to adapt graph-drawing parameters in accordance with the size of a graph.</span>
<a name="line-52"></a>    <span class='hs-varid'>dynamicStyle</span><span class='hs-layout'>,</span>
<a name="line-53"></a>
<a name="line-54"></a>    <span class='hs-comment'>-- * The Lens setter functions to modify their corresponding 'Settings' fields.</span>
<a name="line-55"></a>      <span class='hs-varid'>nodeDrawFunction</span>
<a name="line-56"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>dynamicHead</span>
<a name="line-57"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>dynamicThick</span>
<a name="line-58"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>directed</span>
<a name="line-59"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>horizontalOrientation</span>
<a name="line-60"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>layerSpacing</span>
<a name="line-61"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>nodeSpacing</span>
<a name="line-62"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>graphPadding</span>
<a name="line-63"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>colF</span>
<a name="line-64"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>bgOp</span>
<a name="line-65"></a>    <span class='hs-layout'>,</span> <span class='hs-varid'>initPos</span>
<a name="line-66"></a><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-67"></a>
<a name="line-68"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Algebra</span><span class='hs-varop'>.</span><span class='hs-conid'>Graph</span>
<a name="line-69"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Diagrams</span><span class='hs-varop'>.</span><span class='hs-conid'>Prelude</span>     <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-conid'>Empty</span><span class='hs-layout'>,</span> <span class='hs-varid'>union</span><span class='hs-layout'>)</span>
<a name="line-70"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Diagrams</span><span class='hs-varop'>.</span><span class='hs-conid'>Backend</span><span class='hs-varop'>.</span><span class='hs-conid'>SVG</span>
<a name="line-71"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>
<a name="line-72"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Either</span>
<a name="line-73"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span>
<a name="line-74"></a><span class='hs-comment'>-- import Control.Lens         (Lens', Setter)</span>
<a name="line-75"></a>
<a name="line-76"></a>
<a name="line-77"></a><a name="Settings"></a><span class='hs-comment'>-- | The 'Settings' data type contains various fields for the graph drawing methods, some common between them and some specialised to a single method. Specialised fields use 'Maybe'.</span>
<a name="line-78"></a><a name="Settings"></a><span class='hs-comment'>-- The 'Control.Lens' library is used to enable easy access to and modification of these fields using getters and setters.</span>
<a name="line-79"></a><a name="Settings"></a><span class='hs-comment'>-- To access a field the generated Lens getter functions can be used in conjunction with the inline get function (^.). For example the following test function gets the '_directed' field:</span>
<a name="line-80"></a><a name="Settings"></a><span class='hs-comment'>--</span>
<a name="line-81"></a><a name="Settings"></a><span class='hs-comment'>-- @</span>
<a name="line-82"></a><a name="Settings"></a><span class='hs-comment'>--     getDirectedTest :: Setting a -&gt; Directed</span>
<a name="line-83"></a><a name="Settings"></a><span class='hs-comment'>--     getDirectedTest s = s ^. directed</span>
<a name="line-84"></a><a name="Settings"></a><span class='hs-comment'>-- @</span>
<a name="line-85"></a><a name="Settings"></a><span class='hs-comment'>--</span>
<a name="line-86"></a><a name="Settings"></a><span class='hs-comment'>-- And to set a value in an instance of 'Settings', Lens' setter functions can be used in combination with the inline set function (.~) as shown in the following test function:</span>
<a name="line-87"></a><a name="Settings"></a><span class='hs-comment'>-- (Where (&amp;) is a reverse application operator as defined by Lens and 'with' is a synonym for 'def' to get the default 'Settings' value)</span>
<a name="line-88"></a><a name="Settings"></a><span class='hs-comment'>--</span>
<a name="line-89"></a><a name="Settings"></a><span class='hs-comment'>-- @</span>
<a name="line-90"></a><a name="Settings"></a><span class='hs-comment'>--     setSettingsTest :: Setting a</span>
<a name="line-91"></a><a name="Settings"></a><span class='hs-comment'>--     setSettingsTest = with &amp; directed .~ Directed</span>
<a name="line-92"></a><a name="Settings"></a><span class='hs-comment'>--                            &amp; initPos .~ Just 2</span>
<a name="line-93"></a><a name="Settings"></a><span class='hs-comment'>-- @</span>
<a name="line-94"></a><a name="Settings"></a><span class='hs-comment'>-- </span>
<a name="line-95"></a><a name="Settings"></a><span class='hs-comment'>-- This function uses a default 'Settings' instance and sets the values of the '_directed' and '_initPos' fields.</span>
<a name="line-96"></a><a name="Settings"></a><span class='hs-comment'>-- To set the node-drawing function to a custom function, the -XScopedTypeVariables language extension must be used due to Haskell's polymorphism. </span>
<a name="line-97"></a><a name="Settings"></a><span class='hs-comment'>-- For example to use the 'drawDefaultHierNode' function as the drawing function, the following function could be used:</span>
<a name="line-98"></a><a name="Settings"></a><span class='hs-comment'>--</span>
<a name="line-99"></a><a name="Settings"></a><span class='hs-comment'>-- @</span>
<a name="line-100"></a><a name="Settings"></a><span class='hs-comment'>--     testSetNodeDrawFunction :: (Countable a, Show a) =&gt; Graph a -&gt; Settings a</span>
<a name="line-101"></a><a name="Settings"></a><span class='hs-comment'>--     testSetNodeDrawFunction g = (with :: (Show a) =&gt; Settings a) &amp; (nodeDrawFunction .~ drawDefaultHierNode :: (Show a) =&gt; Settings a -&gt; Settings a)</span>
<a name="line-102"></a><a name="Settings"></a><span class='hs-comment'>-- @</span>
<a name="line-103"></a><a name="Settings"></a><span class='hs-comment'>--</span>
<a name="line-104"></a><a name="Settings"></a><span class='hs-comment'>-- If the type definitions are not present there will be ambiguous types.</span>
<a name="line-105"></a><a name="Settings"></a><span class='hs-comment'>--</span>
<a name="line-106"></a><a name="Settings"></a><span class='hs-comment'>-- Each standard graph-drawing function in the library provides at least one default settings function providing a recommended set of default 'Settings' to be used.</span>
<a name="line-107"></a><a name="Settings"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Settings</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> 
<a name="line-108"></a>  <span class='hs-conid'>Settings</span> <span class='hs-layout'>{</span> <span class='hs-sel'>_nodeDrawFunction</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-109"></a>
<a name="line-110"></a>             <span class='hs-comment'>-- | The size of the arrow heads for the graph drawing, useful to scale with graph size. </span>
<a name="line-111"></a>             <span class='hs-comment'>-- The default implementation for each of the drawing methods is similar, being based on:</span>
<a name="line-112"></a>             <span class='hs-comment'>-- @</span>
<a name="line-113"></a>             <span class='hs-comment'>-- dynamicStyle small $ count g</span>
<a name="line-114"></a>             <span class='hs-comment'>-- @</span>
<a name="line-115"></a>             <span class='hs-comment'>-- With 'normal' being used in place of 'small' for some methods.</span>
<a name="line-116"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_dynamicHead</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Measure</span> <span class='hs-conid'>Double</span>
<a name="line-117"></a>             <span class='hs-comment'>-- | The thickness of the arrow shafts for the graph drawing, again useful to scale like 'dynamicHead' like so:</span>
<a name="line-118"></a>             <span class='hs-comment'>-- @</span>
<a name="line-119"></a>             <span class='hs-comment'>-- dynamicStyle thin $ count g</span>
<a name="line-120"></a>             <span class='hs-comment'>-- @</span>
<a name="line-121"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_dynamicThick</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Measure</span> <span class='hs-conid'>Double</span>
<a name="line-122"></a>             <span class='hs-comment'>-- | Whether the graph is 'Directed' (arrows on the connections between nodes). The type 'Directed' is a boolean value that can either be 'Directed' or 'Undirected'.</span>
<a name="line-123"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_directed</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Directed</span>
<a name="line-124"></a>             <span class='hs-comment'>-- | The orientation of the graph when using the "Visualise.Tree" module's functions.</span>
<a name="line-125"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_horizontalOrientation</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Bool</span>
<a name="line-126"></a>             <span class='hs-comment'>-- | The spacing between layers when using the "Visualise.Tree" module's functions.</span>
<a name="line-127"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_layerSpacing</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Double</span>
<a name="line-128"></a>             <span class='hs-comment'>-- | The spacing between vertices when using the "Visualise.Tree" module's functions.</span>
<a name="line-129"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_nodeSpacing</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Double</span>
<a name="line-130"></a>             <span class='hs-comment'>-- | The padding around the graph when using the "Visualise.Tree" module's functions.</span>
<a name="line-131"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_graphPadding</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Double</span>
<a name="line-132"></a>             <span class='hs-comment'>-- | The background colour of groups when using the "Visualise.Hierarchical" module.</span>
<a name="line-133"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_colF</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Colour</span> <span class='hs-conid'>Double</span><span class='hs-layout'>)</span>
<a name="line-134"></a>             <span class='hs-comment'>-- | The background opacity of groups when using the "Visualise.Hierarchical" module.</span>
<a name="line-135"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_bgOp</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Double</span>
<a name="line-136"></a>             <span class='hs-comment'>-- | The mode of initial positioning for the vertices when using "Visualise.FlatAdaptive", changing this results in differently layed out graphs. </span>
<a name="line-137"></a>             <span class='hs-comment'>-- Useful to experiment with to best display a graph.</span>
<a name="line-138"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_initPos</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Maybe</span> <span class='hs-conid'>Int</span>
<a name="line-139"></a>          <span class='hs-layout'>}</span>
<a name="line-140"></a>
<a name="line-141"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>-- | Provides a set of default values a 'Settings' instance.</span>
<a name="line-142"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>-- By default these are used:</span>
<a name="line-143"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--</span>
<a name="line-144"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>-- @</span>
<a name="line-145"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _nodeDrawFunction = drawDefaultNode,</span>
<a name="line-146"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _dynamicHead = small,</span>
<a name="line-147"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _dynamicThick = thin,</span>
<a name="line-148"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _directed = Directed,</span>
<a name="line-149"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _horizontalOrientation = Nothing,</span>
<a name="line-150"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _layerSpacing = Nothing,</span>
<a name="line-151"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _nodeSpacing = Nothing,</span>
<a name="line-152"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _graphPadding = Nothing,</span>
<a name="line-153"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _colF = Nothing,</span>
<a name="line-154"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _bgOp = Nothing,</span>
<a name="line-155"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--     _initPos = Nothing</span>
<a name="line-156"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>-- @</span>
<a name="line-157"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>--</span>
<a name="line-158"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-comment'>-- These defaults are then customised by the various default settings methods in the drawing modules.</span>
<a name="line-159"></a><a name="instance%20Default%20(Settings%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Default</span> <span class='hs-layout'>(</span><span class='hs-conid'>Settings</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-160"></a>  <span class='hs-varid'>def</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Settings</span> <span class='hs-layout'>{</span>
<a name="line-161"></a>             <span class='hs-sel'>_nodeDrawFunction</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>drawDefaultNode</span>
<a name="line-162"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_dynamicHead</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>small</span>
<a name="line-163"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_dynamicThick</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>thin</span>
<a name="line-164"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_directed</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Directed</span>
<a name="line-165"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_horizontalOrientation</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-166"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_layerSpacing</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-167"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_nodeSpacing</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-168"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_graphPadding</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-169"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_colF</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-170"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_bgOp</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-171"></a>           <span class='hs-layout'>,</span> <span class='hs-sel'>_initPos</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Nothing</span>
<a name="line-172"></a>          <span class='hs-layout'>}</span>
<a name="line-173"></a>
<a name="line-174"></a><a name="Node"></a><span class='hs-comment'>-- | The 'Node' data type represents a node/vertex on a graph, storing the node's String name and its corrisponding diagram from the "Diagrams" library.</span>
<a name="line-175"></a><a name="Node"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Node</span> <span class='hs-keyglyph'>=</span> 
<a name="line-176"></a>  <span class='hs-conid'>Node</span> <span class='hs-layout'>{</span> <span class='hs-comment'>-- | Use 'name' to get the String representation of a node.</span>
<a name="line-177"></a>         <span class='hs-varid'>name</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>String</span>
<a name="line-178"></a>         <span class='hs-comment'>-- | Use 'diag' to get the "Diagrams" representation of a node.</span>
<a name="line-179"></a>       <span class='hs-layout'>,</span> <span class='hs-varid'>diag</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-180"></a>       <span class='hs-layout'>}</span>
<a name="line-181"></a>
<a name="line-182"></a><a name="ProcessedGraph"></a><span class='hs-comment'>-- | The 'ProcessedGraph' data type contains a list of a graph's nodes along with the connections between them in a list of tuples.</span>
<a name="line-183"></a><a name="ProcessedGraph"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>ProcessedGraph</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ProcessedGraph</span> <span class='hs-keyglyph'>[</span><span class='hs-conid'>Node</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-conid'>Node</span><span class='hs-layout'>,</span> <span class='hs-conid'>Node</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span><span class='hs-layout'>)</span>
<a name="line-184"></a>
<a name="line-185"></a><a name="Directed"></a><span class='hs-comment'>-- | The 'Directed' data type is a boolean type which is used to determine if a graph is a directed or undiercted graph.</span>
<a name="line-186"></a><a name="Directed"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>Directed</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Directed</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>Undirected</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-187"></a>
<a name="line-188"></a><a name="ConnectList"></a><span class='hs-comment'>-- | The type 'ConnectList' is an alias for an array of tuples that can be used where the first element in each tuple is a vertex and the second element is an array of the connected vertices - i.e. an adjacency list if the connected bvertices are only vertices dependant on the vertex.</span>
<a name="line-189"></a><a name="ConnectList"></a><span class='hs-keyword'>type</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-190"></a>
<a name="line-191"></a><a name="Draw"></a><span class='hs-comment'>-- | The TypeClass 'Draw' is used to determine whether a value can be drawn, this is used for vertices as these must be able to be drawn.</span>
<a name="line-192"></a><a name="Draw"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Draw</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-193"></a>    <span class='hs-comment'>-- | The draw function produces a &lt;https://hackage.haskell.org/package/diagrams Diagram&gt; from the drawable value.</span>
<a name="line-194"></a>    <span class='hs-varid'>draw</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-195"></a>
<a name="line-196"></a><a name="instance%20Draw%20Node"></a><span class='hs-comment'>-- | The type 'Node' is an instance of the 'Draw' class as it can be drawn.</span>
<a name="line-197"></a><a name="instance%20Draw%20Node"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Draw</span> <span class='hs-conid'>Node</span> <span class='hs-keyword'>where</span>
<a name="line-198"></a>    <span class='hs-comment'>-- | The diagram is extracted from the 'Node'.</span>
<a name="line-199"></a>    <span class='hs-varid'>draw</span> <span class='hs-layout'>(</span><span class='hs-conid'>Node</span> <span class='hs-keyword'>_</span> <span class='hs-varid'>d</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>d</span>
<a name="line-200"></a>
<a name="line-201"></a><a name="Countable"></a><span class='hs-comment'>-- | The TypeClass 'Countable' is used to determine if a type can be counted when counting the number of vertices in a graph/more specificaly a nested graph.</span>
<a name="line-202"></a><a name="Countable"></a><span class='hs-keyword'>class</span> <span class='hs-conid'>Countable</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>where</span>
<a name="line-203"></a>    <span class='hs-comment'>-- | The count function gives an Integer representing the number of vertices in a.</span>
<a name="line-204"></a>    <span class='hs-varid'>count</span> <span class='hs-keyglyph'>::</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span>
<a name="line-205"></a>
<a name="line-206"></a><a name="instance%20Countable%20(Graph%20a)"></a><span class='hs-comment'>-- | The type 'Graph a' where 'a' itself is an instance of 'Countable' is an instance of the TypeClass 'Countable'.</span>
<a name="line-207"></a><a name="instance%20Countable%20(Graph%20a)"></a><span class='hs-keyword'>instance</span> <span class='hs-layout'>(</span><span class='hs-conid'>Countable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Countable</span> <span class='hs-layout'>(</span><span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-208"></a>    <span class='hs-comment'>-- | To count the number of vertices in the given graph, the graph is folded over using "Algebra.Graph"'s 'foldg' function.</span>
<a name="line-209"></a>    <span class='hs-comment'>-- Empty vertices are counted as 1, each vertex has 'count' called recursively called on it (for if the graph is a graph of graphs) and for overlays and connections the number of vertices in each branch are added.</span>
<a name="line-210"></a>    <span class='hs-varid'>count</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldg</span> <span class='hs-num'>1</span> <span class='hs-varid'>count</span> <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varop'>+</span><span class='hs-layout'>)</span>
<a name="line-211"></a>
<a name="line-212"></a><a name="instance%20Countable%20String"></a><span class='hs-comment'>-- | The possible types for vertex contents are also instances of 'Countable', starting with 'String'.</span>
<a name="line-213"></a><a name="instance%20Countable%20String"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Countable</span> <span class='hs-conid'>String</span> <span class='hs-keyword'>where</span>
<a name="line-214"></a>    <span class='hs-comment'>-- | A String can only be a single Vertex so is counted as 1.</span>
<a name="line-215"></a>    <span class='hs-varid'>count</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-216"></a>
<a name="line-217"></a><a name="instance%20Countable%20Int"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Countable</span> <span class='hs-conid'>Int</span> <span class='hs-keyword'>where</span>
<a name="line-218"></a>    <span class='hs-varid'>count</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-219"></a>
<a name="line-220"></a><a name="instance%20Countable%20Char"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Countable</span> <span class='hs-conid'>Char</span> <span class='hs-keyword'>where</span>
<a name="line-221"></a>    <span class='hs-varid'>count</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-222"></a>
<a name="line-223"></a><a name="instance%20Countable%20(String,Bool)"></a><span class='hs-comment'>-- | This type is a tuple of a String (the contents of the vertex) and a boolean flag that can be used to choose whether to display the Vertex with the String name or as an Empty Vertex.</span>
<a name="line-224"></a><a name="instance%20Countable%20(String,Bool)"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Countable</span> <span class='hs-layout'>(</span><span class='hs-conid'>String</span><span class='hs-layout'>,</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-225"></a>    <span class='hs-comment'>-- | Can only be a single Vertex, so counted as 1.</span>
<a name="line-226"></a>    <span class='hs-varid'>count</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>1</span>
<a name="line-227"></a>
<a name="line-228"></a><a name="instance%20Eq%20Node"></a><span class='hs-comment'>-- | 'Node's can naturally be equated so are instances of the Eq TypeClass.</span>
<a name="line-229"></a><a name="instance%20Eq%20Node"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Eq</span> <span class='hs-conid'>Node</span> <span class='hs-keyword'>where</span>
<a name="line-230"></a>    <span class='hs-comment'>-- | Compares the String element of the two 'Node's, ignoring the Diagram element.</span>
<a name="line-231"></a>    <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>name</span> <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>name</span> <span class='hs-varid'>b</span>
<a name="line-232"></a>
<a name="line-233"></a><a name="instance%20Show%20Node"></a><span class='hs-comment'>-- | 'Node's need to be shown in order to obtain a String representation of them for use as a SubDiagram name to enable the linking of vertices with arrows</span>
<a name="line-234"></a><a name="instance%20Show%20Node"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Show</span> <span class='hs-conid'>Node</span> <span class='hs-keyword'>where</span>
<a name="line-235"></a>    <span class='hs-comment'>-- | Simply gives the 'name' element of the 'Node'</span>
<a name="line-236"></a>    <span class='hs-varid'>show</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>name</span>
<a name="line-237"></a>
<a name="line-238"></a><a name="instance%20Ord%20Node"></a><span class='hs-comment'>-- | 'Node's need to be an instance of the Ord typeclass for use with the "Visualise.GraphViz" module</span>
<a name="line-239"></a><a name="instance%20Ord%20Node"></a><span class='hs-keyword'>instance</span> <span class='hs-conid'>Ord</span> <span class='hs-conid'>Node</span> <span class='hs-keyword'>where</span>
<a name="line-240"></a>    <span class='hs-comment'>-- | To compare the ordering of two nodes, their Diagram elements are ignored and their String 'name's are compared.</span>
<a name="line-241"></a>    <span class='hs-varid'>a</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`compare`</span> <span class='hs-varid'>show</span> <span class='hs-varid'>b</span>
<a name="line-242"></a>
<a name="line-243"></a><a name="drawDefaultNode"></a><span class='hs-comment'>-- | Produces a default node á la 'drawDefaultNodeWithSize' with a size of '0.1'.</span>
<a name="line-244"></a><span class='hs-definition'>drawDefaultNode</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-245"></a><span class='hs-definition'>drawDefaultNode</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>drawDefaultNodeWithSize</span> <span class='hs-num'>0.1</span> <span class='hs-varid'>n</span>
<a name="line-246"></a>
<a name="line-247"></a><a name="drawDefaultNodeWithSize"></a><span class='hs-comment'>-- | The default drawing function to produce a single node but of the specified size, in the form of a 'Diagram B', containing some showable text.</span>
<a name="line-248"></a><span class='hs-comment'>-- Also makes the node a link, so if the drawn graph is saved as an SVG file each vertex is clickable with a JavaScript alert giving the vertex's name.</span>
<a name="line-249"></a><span class='hs-definition'>drawDefaultNodeWithSize</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-250"></a><span class='hs-definition'>drawDefaultNodeWithSize</span> <span class='hs-varid'>s</span> <span class='hs-varid'>nn</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-varid'>n</span> <span class='hs-cpp'>#</span> <span class='hs-varid'>fontSizeL</span> <span class='hs-varid'>s</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>drawDefaultEmptyNode</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-cpp'>#</span> <span class='hs-varid'>href</span> <span class='hs-layout'>(</span><span class='hs-str'>"javascript:alert(\"Node "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>n</span> <span class='hs-varop'>++</span> <span class='hs-str'>"\")"</span><span class='hs-layout'>)</span>
<a name="line-251"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>n</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>show</span> <span class='hs-varid'>nn</span>
<a name="line-252"></a>
<a name="line-253"></a><a name="drawDefaultEmptyNode"></a><span class='hs-comment'>-- | The default circle &lt;https://hackage.haskell.org/package/diagrams Diagram&gt; for an empty node of the size provided.</span>
<a name="line-254"></a><span class='hs-definition'>drawDefaultEmptyNode</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-255"></a><span class='hs-definition'>drawDefaultEmptyNode</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>circle</span>
<a name="line-256"></a>
<a name="line-257"></a><a name="drawNodeWithEmptyFlag"></a><span class='hs-comment'>-- | The same as 'drawDefaultNode' but instead takes a tuple of a showable value and a boolean flag. </span>
<a name="line-258"></a><span class='hs-comment'>-- If the flag is True then it means the vertex should be displayed as an empty vertex with no contents, but if the flag is true the vertex is drawn as normal.</span>
<a name="line-259"></a><span class='hs-definition'>drawNodeWithEmptyFlag</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-conid'>Bool</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-260"></a><span class='hs-definition'>drawNodeWithEmptyFlag</span> <span class='hs-layout'>(</span><span class='hs-varid'>n</span><span class='hs-layout'>,</span><span class='hs-varid'>f</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-varid'>txt</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>f</span> <span class='hs-keyword'>then</span> <span class='hs-str'>""</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>show</span> <span class='hs-varid'>n</span> 
<a name="line-261"></a>                              <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>text</span> <span class='hs-varid'>txt</span> <span class='hs-cpp'>#</span> <span class='hs-varid'>fontSizeL</span> <span class='hs-num'>0.1</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>circle</span> <span class='hs-num'>0.1</span><span class='hs-layout'>)</span> <span class='hs-cpp'>#</span> <span class='hs-varid'>href</span> <span class='hs-layout'>(</span><span class='hs-str'>"javascript:alert(\"Node "</span> <span class='hs-varop'>++</span> <span class='hs-varid'>txt</span> <span class='hs-varop'>++</span> <span class='hs-str'>"\")"</span><span class='hs-layout'>)</span>
<a name="line-262"></a>
<a name="line-263"></a><a name="getNode"></a><span class='hs-comment'>-- | Produces a value of the type 'Node'. The corrisponding diagram for the node is proudced by the @ (a -&gt; Diagram B) @ function if the value contained in the 'Either' parameter is the 'Right' 'a' value.</span>
<a name="line-264"></a><span class='hs-comment'>-- The 'Either' parameter is 'Left' if the 'Node' is an &lt;https://hackage.haskell.org/package/algebraic-graphs-0.1.1.1/docs/Algebra-Graph.html#t:Graph Empty&gt; node meaning that the 'Node''s name is the value of the 'c' accumulator from 'namesAndConnections' and its &lt;https://hackage.haskell.org/package/diagrams Diagram&gt; should be a blank node.</span>
<a name="line-265"></a><span class='hs-comment'>-- If the 'Either' parameter is instead 'Right', the 'Node''s 'name' is be produced using 'show' on the provided value and the associated diagram is produced from applying the provided Right value to the provided function.</span>
<a name="line-266"></a><span class='hs-definition'>getNode</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Either</span> <span class='hs-conid'>String</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Node</span>
<a name="line-267"></a><span class='hs-definition'>getNode</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>x</span>
<a name="line-268"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>isRight</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-varop'>.</span> <span class='hs-varid'>head</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rights</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>drawF</span> <span class='hs-varop'>.</span> <span class='hs-varid'>head</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rights</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-cpp'>#</span> <span class='hs-varid'>named</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-varop'>.</span> <span class='hs-varid'>head</span> <span class='hs-varop'>.</span> <span class='hs-varid'>rights</span> <span class='hs-varop'>$</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-269"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Node</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromLeft</span> <span class='hs-str'>""</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>drawDefaultEmptyNode</span> <span class='hs-num'>0.1</span> <span class='hs-cpp'>#</span> <span class='hs-varid'>named</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromLeft</span> <span class='hs-str'>""</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-270"></a>
<a name="line-271"></a><a name="getVertices"></a><span class='hs-comment'>-- | Essentially a wrapper for the recursive 'namesAndConnections' function. Takes a Diagram-producing function and a Graph of the same type the Diagram function takes and then produces a 'ProcessedGraph' containign all the vertices (their names and diagrams) and connections of the original graph.</span>
<a name="line-272"></a><span class='hs-definition'>getVertices</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- ^ A function that takes a vertex of the graph of type 'a' and produces a &lt;https://hackage.haskell.org/package/diagrams Diagram&gt; from it.</span>
<a name="line-273"></a>                              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span>            <span class='hs-comment'>-- ^ The graph to be folded through.</span>
<a name="line-274"></a>                              <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ProcessedGraph</span>     <span class='hs-comment'>-- ^ Contains the produced 'Node''s and connections.</span>
<a name="line-275"></a><span class='hs-definition'>getVertices</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>namesAndConnections</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>g</span> <span class='hs-str'>""</span>
<a name="line-276"></a>
<a name="line-277"></a><a name="namesAndConnections"></a><span class='hs-comment'>-- | Recursively goes through the provided graph. Produces a list of 'Node''s (so the 'name' and associated &lt;https://hackage.haskell.org/package/diagrams Diagram&gt; for each vertex) and a list of connections between them.</span>
<a name="line-278"></a><span class='hs-definition'>namesAndConnections</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span><span class='hs-layout'>)</span>   <span class='hs-comment'>-- ^ A function that takes a vertex of the graph of type 'a' and produces a &lt;https://hackage.haskell.org/package/diagrams Diagram&gt; from it.</span>
<a name="line-279"></a>                                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span>            <span class='hs-comment'>-- ^ The graph to be folded through.</span>
<a name="line-280"></a>                                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span>             <span class='hs-comment'>-- ^ An accumulator used to produce identifiers for &lt;https://hackage.haskell.org/package/algebraic-graphs-0.1.1.1/docs/Algebra-Graph.html#t:Graph Empty&gt; vertices, each iteration an 'l' or 'r' is prepended.</span>
<a name="line-281"></a>                                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ProcessedGraph</span>     <span class='hs-comment'>-- ^ Contains the produced 'Node''s and connections.</span>
<a name="line-282"></a><span class='hs-definition'>namesAndConnections</span> <span class='hs-varid'>drawF</span> <span class='hs-conid'>Empty</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ProcessedGraph</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>getNode</span> <span class='hs-varid'>drawF</span> <span class='hs-layout'>(</span><span class='hs-conid'>Left</span> <span class='hs-layout'>(</span><span class='hs-str'>"_empty_node_"</span> <span class='hs-varop'>++</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>[]</span>
<a name="line-283"></a><span class='hs-definition'>namesAndConnections</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>v</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-conid'>Vertex</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ProcessedGraph</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>getNode</span> <span class='hs-varid'>drawF</span> <span class='hs-layout'>(</span><span class='hs-conid'>Right</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-conid'>[]</span>
<a name="line-284"></a><span class='hs-definition'>namesAndConnections</span> <span class='hs-varid'>drawF</span> <span class='hs-layout'>(</span><span class='hs-conid'>Overlay</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ProcessedGraph</span> <span class='hs-layout'>(</span><span class='hs-varid'>nA</span> <span class='hs-varop'>`union`</span> <span class='hs-varid'>nB</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>cA</span> <span class='hs-varop'>`union`</span> <span class='hs-varid'>cB</span><span class='hs-layout'>)</span>
<a name="line-285"></a>    <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-conid'>ProcessedGraph</span> <span class='hs-varid'>nA</span> <span class='hs-varid'>cA</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>namesAndConnections</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-chr'>'l'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-286"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>ProcessedGraph</span> <span class='hs-varid'>nB</span> <span class='hs-varid'>cB</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>namesAndConnections</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-chr'>'r'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-287"></a><span class='hs-definition'>namesAndConnections</span> <span class='hs-varid'>drawF</span> <span class='hs-layout'>(</span><span class='hs-conid'>Connect</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>c</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>ProcessedGraph</span> <span class='hs-layout'>(</span><span class='hs-varid'>nA</span> <span class='hs-varop'>`union`</span> <span class='hs-varid'>nB</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>aA</span><span class='hs-layout'>,</span> <span class='hs-varid'>bB</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>|</span> <span class='hs-varid'>aA</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nA</span><span class='hs-layout'>,</span> <span class='hs-varid'>bB</span> <span class='hs-keyglyph'>&lt;-</span> <span class='hs-varid'>nB</span><span class='hs-keyglyph'>]</span> <span class='hs-varop'>`union`</span> <span class='hs-varid'>cA</span> <span class='hs-varop'>`union`</span> <span class='hs-varid'>cB</span><span class='hs-layout'>)</span>
<a name="line-288"></a>    <span class='hs-keyword'>where</span> <span class='hs-layout'>(</span><span class='hs-conid'>ProcessedGraph</span> <span class='hs-varid'>nA</span> <span class='hs-varid'>cA</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>namesAndConnections</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>a</span> <span class='hs-layout'>(</span><span class='hs-chr'>'l'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-289"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>ProcessedGraph</span> <span class='hs-varid'>nB</span> <span class='hs-varid'>cB</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>namesAndConnections</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-chr'>'r'</span> <span class='hs-conop'>:</span> <span class='hs-varid'>c</span><span class='hs-layout'>)</span>
<a name="line-290"></a>
<a name="line-291"></a><a name="connectedTo"></a><span class='hs-comment'>-- | Takes a list of connections and produces a corrisponding adjacency list (so tuples of a vertex and a list of vertices dependant on it) by using folds and recursion.</span>
<a name="line-292"></a><span class='hs-definition'>connectedTo</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>        <span class='hs-comment'>-- ^ A list of tuples where the first tuple element and second tuple element are used to corrispond to the vertex at the tail of the conenction and at the head of connection respectively.</span>
<a name="line-293"></a>                      <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>  <span class='hs-comment'>-- ^ The corrisponding adjacency list to the list of the connections.</span>
<a name="line-294"></a><span class='hs-definition'>connectedTo</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-295"></a><span class='hs-definition'>connectedTo</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-296"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-297"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>y</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-298"></a><span class='hs-definition'>connectedTo</span> <span class='hs-varid'>l</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>zs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>outgoing</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>remaining</span><span class='hs-layout'>)</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>connectedTo</span> <span class='hs-varid'>remaining</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>[]</span>
<a name="line-299"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>remaining</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zs</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>filtered</span>
<a name="line-300"></a>          <span class='hs-varid'>outgoing</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>filtered</span>
<a name="line-301"></a>          <span class='hs-varid'>filtered</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span>
<a name="line-302"></a>
<a name="line-303"></a><a name="connectedFrom"></a><span class='hs-comment'>-- | Similar to 'connectedTo', takes a list of connections and produces a 'ConnectList' containing the vertices that each vertex depends on.</span>
<a name="line-304"></a><span class='hs-definition'>connectedFrom</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>
<a name="line-305"></a><span class='hs-definition'>connectedFrom</span> <span class='hs-conid'>[]</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-306"></a><span class='hs-definition'>connectedFrom</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>,</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-307"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>b</span> <span class='hs-varop'>==</span> <span class='hs-varid'>y</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-308"></a>  <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>b</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-309"></a><span class='hs-definition'>connectedFrom</span> <span class='hs-varid'>l</span><span class='hs-keyglyph'>@</span><span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>zs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>y</span><span class='hs-layout'>,</span><span class='hs-varid'>incoming</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>not</span> <span class='hs-layout'>(</span><span class='hs-varid'>null</span> <span class='hs-varid'>remaining</span><span class='hs-layout'>)</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>connectedFrom</span> <span class='hs-varid'>remaining</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>[]</span>
<a name="line-310"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>remaining</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>zs</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>filtered</span>
<a name="line-311"></a>          <span class='hs-varid'>incoming</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>filtered</span>
<a name="line-312"></a>          <span class='hs-varid'>filtered</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>filter</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>b</span> <span class='hs-varop'>==</span> <span class='hs-varid'>y</span><span class='hs-layout'>)</span> <span class='hs-varid'>l</span>
<a name="line-313"></a>
<a name="line-314"></a><a name="dynamicStyle"></a><span class='hs-comment'>-- | Used to produce a measurement for the size of &lt;https://hackage.haskell.org/package/diagrams Diagram&gt; properties from a default measurement and the size of a graph as an 'Integer'.</span>
<a name="line-315"></a><span class='hs-comment'>-- Multiplies the default value by 10 and divides this new value by the size of the graph.</span>
<a name="line-316"></a><span class='hs-definition'>dynamicStyle</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Measure</span> <span class='hs-conid'>Double</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Int</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Measure</span> <span class='hs-conid'>Double</span>
<a name="line-317"></a><span class='hs-definition'>dynamicStyle</span> <span class='hs-varid'>def</span> <span class='hs-varid'>graphSize</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>def</span> <span class='hs-varop'>*</span> <span class='hs-num'>10</span><span class='hs-varop'>/</span><span class='hs-varid'>fromIntegral</span> <span class='hs-varid'>graphSize</span>
<a name="line-318"></a>
<a name="line-319"></a><a name="makeLenses"></a><span class='hs-comment'>-- Uses TemplateHaskell to create lenses for each 'Settings' field using the Control.Lens library.</span>
<a name="line-320"></a><span class='hs-definition'>makeLenses</span> <span class='hs-chr'>'</span><span class='hs-chr'>'</span><span class='hs-conid'>Settings</span>
</pre></body>
</html>
