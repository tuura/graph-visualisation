<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<head>
<!-- Generated by HsColour, http://code.haskell.org/~malcolm/hscolour/ -->
<title>src/Visualise/Tree.hs</title>
<link type='text/css' rel='stylesheet' href='hscolour.css' />
</head>
<body>
<pre><a name="line-1"></a><span class='hs-comment'>{-# LANGUAGE NoMonomorphismRestriction #-}</span>
<a name="line-2"></a><span class='hs-comment'>{-# LANGUAGE FlexibleContexts          #-}</span>
<a name="line-3"></a><span class='hs-comment'>{-# LANGUAGE TypeFamilies              #-}</span>
<a name="line-4"></a><span class='hs-comment'>{-# LANGUAGE MultiParamTypeClasses #-}</span>
<a name="line-5"></a><span class='hs-comment'>{-# LANGUAGE ScopedTypeVariables #-}</span>
<a name="line-6"></a><span class='hs-comment'>{-# LANGUAGE FlexibleInstances #-}</span>
<a name="line-7"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-8"></a><span class='hs-comment'>-- |</span>
<a name="line-9"></a><span class='hs-comment'>-- Module: Visualise.Tree</span>
<a name="line-10"></a><span class='hs-comment'>-- Copyright : (c) Sam Prescott 2018</span>
<a name="line-11"></a><span class='hs-comment'>-- </span>
<a name="line-12"></a><span class='hs-comment'>-- Enables a 'Graph' to be drawn in a 'Tree' style. Provides four drawing</span>
<a name="line-13"></a><span class='hs-comment'>-- functions: 'drawTree' to draw the graph with default 'Settings' and 'drawTree''</span>
<a name="line-14"></a><span class='hs-comment'>-- allows the 'Settings' to be customised, as well as 'drawTreePartialOrder' </span>
<a name="line-15"></a><span class='hs-comment'>-- which uses the Coffman-Graham algorithm to remove indirect connections</span>
<a name="line-16"></a><span class='hs-comment'>-- for directed acyclic graphs and 'drawTreePartialOrder'' which does the same</span>
<a name="line-17"></a><span class='hs-comment'>-- but allows the 'Settings' to be specified.</span>
<a name="line-18"></a><span class='hs-comment'>--</span>
<a name="line-19"></a><span class='hs-comment'>-----------------------------------------------------------------------------</span>
<a name="line-20"></a><span class='hs-keyword'>module</span> <span class='hs-conid'>Visualise</span><span class='hs-varop'>.</span><span class='hs-conid'>Tree</span> <span class='hs-layout'>(</span>
<a name="line-21"></a>    <span class='hs-comment'>-- * The main drawing function: the full 'Graph' as specified with default 'Settings'.</span>
<a name="line-22"></a>    <span class='hs-varid'>drawTree</span><span class='hs-layout'>,</span> 
<a name="line-23"></a>
<a name="line-24"></a>    <span class='hs-comment'>-- * Allows the 'Settings' to be customised.</span>
<a name="line-25"></a>    <span class='hs-varid'>drawTree'</span><span class='hs-layout'>,</span> 
<a name="line-26"></a>
<a name="line-27"></a>    <span class='hs-comment'>-- * Removes indirect connections using the Coffman-Graham algorithm before drawing.</span>
<a name="line-28"></a>    <span class='hs-varid'>drawTreePartialOrder</span><span class='hs-layout'>,</span> <span class='hs-varid'>drawTreePartialOrder'</span><span class='hs-layout'>,</span> 
<a name="line-29"></a>
<a name="line-30"></a>    <span class='hs-comment'>-- * The default 'Settings' functions used with 'drawTree'' and 'drawTreePartialOrder''.</span>
<a name="line-31"></a>    <span class='hs-varid'>defaultTreeSettings</span><span class='hs-layout'>,</span> <span class='hs-varid'>defaultTreeSettingsHorizontal</span>
<a name="line-32"></a><span class='hs-layout'>)</span> <span class='hs-keyword'>where</span>
<a name="line-33"></a>
<a name="line-34"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Visualise</span><span class='hs-varop'>.</span><span class='hs-conid'>Common</span>
<a name="line-35"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Algebra</span><span class='hs-varop'>.</span><span class='hs-conid'>Graph</span>
<a name="line-36"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Diagrams</span><span class='hs-varop'>.</span><span class='hs-conid'>Prelude</span>     <span class='hs-varid'>hiding</span> <span class='hs-layout'>(</span><span class='hs-conid'>Empty</span><span class='hs-layout'>,</span> <span class='hs-varid'>union</span><span class='hs-layout'>)</span>
<a name="line-37"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Diagrams</span><span class='hs-varop'>.</span><span class='hs-conid'>Backend</span><span class='hs-varop'>.</span><span class='hs-conid'>SVG</span>
<a name="line-38"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Diagrams</span><span class='hs-varop'>.</span><span class='hs-conid'>Path</span>
<a name="line-39"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>List</span>
<a name="line-40"></a><span class='hs-keyword'>import</span> <span class='hs-conid'>Data</span><span class='hs-varop'>.</span><span class='hs-conid'>Maybe</span>
<a name="line-41"></a>
<a name="line-42"></a><a name="LayerPosition"></a><span class='hs-comment'>-- | The 'LayerPosition' data type provides three type constructors, which can be used to determine if a 'Node' is on the left, middle or right of a layer.</span>
<a name="line-43"></a><a name="LayerPosition"></a><span class='hs-keyword'>data</span> <span class='hs-conid'>LayerPosition</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LayerLeft</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LayerMiddle</span> <span class='hs-keyglyph'>|</span> <span class='hs-conid'>LayerRight</span> <span class='hs-keyword'>deriving</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span><span class='hs-layout'>)</span>
<a name="line-44"></a>
<a name="line-45"></a><a name="reduction"></a><span class='hs-comment'>-- | Removes indirect dependancies from a graph represented as an adjacency list (as a 'ConnectList') using the Coffman-Graham algorithm, thus simplifying the graph. This can only be done on partial order graphs.</span>
<a name="line-46"></a><span class='hs-comment'>-- Recursively goes through the 'ConnectList' folding through the list of connected vertices for each vertex, each time folding through the rest of the 'ConnectList'.</span>
<a name="line-47"></a><span class='hs-comment'>-- If the first element of a tuple matches this current vertex then any elements in the list contained in the second element of the matched tuple are removed from the list currently being folded through.</span>
<a name="line-48"></a><span class='hs-definition'>reduction</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>  <span class='hs-comment'>-- ^ The graph in adjacency list form represented as a 'ConnectList'</span>
<a name="line-49"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>  <span class='hs-comment'>-- ^ Used internally for recursion - the first part of the list that still needs to be checked through</span>
<a name="line-50"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>  <span class='hs-comment'>-- ^ The resultant reduced adjacency list</span>
<a name="line-51"></a><span class='hs-definition'>reduction</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-52"></a><span class='hs-definition'>reduction</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>ys</span><span class='hs-layout'>)</span><span class='hs-conop'>:</span><span class='hs-varid'>zs</span><span class='hs-layout'>)</span> <span class='hs-varid'>extras</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>new</span> <span class='hs-conop'>:</span> <span class='hs-varid'>reduction</span> <span class='hs-varid'>zs</span> <span class='hs-layout'>(</span><span class='hs-varid'>new</span> <span class='hs-conop'>:</span> <span class='hs-varid'>extras</span><span class='hs-layout'>)</span>
<a name="line-53"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>new</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>nub</span> <span class='hs-varop'>$</span> <span class='hs-varid'>foldr</span> <span class='hs-varid'>check</span> <span class='hs-varid'>ys</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<a name="line-54"></a>          <span class='hs-varid'>check</span> <span class='hs-varid'>y</span> <span class='hs-varid'>accOuter</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>y</span> <span class='hs-varop'>==</span> <span class='hs-varid'>a</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>acc</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>bs</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-varid'>accOuter</span> <span class='hs-varid'>toCheck</span>
<a name="line-55"></a>          <span class='hs-varid'>toCheck</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>extras</span> <span class='hs-varop'>++</span> <span class='hs-varid'>zs</span>
<a name="line-56"></a>
<a name="line-57"></a><a name="getRoots"></a><span class='hs-comment'>-- | Finds the vertices that don't depend on any other vertices - i.e. the roots of the graph.</span>
<a name="line-58"></a><span class='hs-comment'>-- Folds through the graph's adjacency list and deletes </span>
<a name="line-59"></a><span class='hs-definition'>getRoots</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-60"></a><span class='hs-definition'>getRoots</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>delete</span> <span class='hs-varid'>x</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span>
<a name="line-61"></a>
<a name="line-62"></a><a name="getLevelList"></a><span class='hs-comment'>-- | Topological sorting of a graph represented by a list of vertices and a 'ConnectList' of vertex connections.</span>
<a name="line-63"></a><span class='hs-comment'>-- It sorts the graph by using Kahn's algorithm, producing an ordered list of vertices.</span>
<a name="line-64"></a><span class='hs-definition'>getLevelList</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>            <span class='hs-comment'>-- ^ The initial list of vertices that roots in the graph</span>
<a name="line-65"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>  <span class='hs-comment'>-- ^ The adjacency list for the graph</span>
<a name="line-66"></a>                       <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>            <span class='hs-comment'>-- ^ The topologically ordered list, or partial list as 'getLevelList' is recursive.</span>
<a name="line-67"></a><span class='hs-definition'>getLevelList</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-68"></a><span class='hs-definition'>getLevelList</span> <span class='hs-varid'>q</span> <span class='hs-varid'>firstCTo</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>queue</span><span class='hs-layout'>,</span><span class='hs-varid'>list</span><span class='hs-layout'>,</span><span class='hs-varid'>cTo</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldThroughRoots</span> <span class='hs-varid'>q</span> <span class='hs-varid'>firstCTo</span>
<a name="line-69"></a>                          <span class='hs-keyword'>in</span> <span class='hs-varid'>list</span> <span class='hs-varop'>++</span> <span class='hs-varid'>getLevelList</span> <span class='hs-varid'>queue</span> <span class='hs-varid'>cTo</span>
<a name="line-70"></a>          
<a name="line-71"></a><a name="foldThroughRoots"></a><span class='hs-comment'>-- | Folds through the current list of roots (vertices with no incoming conenctions) and folds through each root's connections to generate part of the sorted list.</span>
<a name="line-72"></a><span class='hs-comment'>-- Adds the current root to the sorted list, then folds over its nodes using 'foldThroughConnectedNodes' and adds any nodes which no longer have other connections to the list.</span>
<a name="line-73"></a><span class='hs-definition'>foldThroughRoots</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>                        <span class='hs-comment'>-- ^ The current queue/roots.</span>
<a name="line-74"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>              <span class='hs-comment'>-- ^ The current adjacency list -- modified by previous executions of 'foldThroughRoots' to update the removed connections.</span>
<a name="line-75"></a>                           <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- ^ The first element is the new queue/new roots, the second element is the updated sorted list and the third element is the new adjacency list.</span>
<a name="line-76"></a><span class='hs-definition'>foldThroughRoots</span> <span class='hs-varid'>queue</span> <span class='hs-varid'>firstCTo</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>root</span> <span class='hs-layout'>(</span><span class='hs-varid'>accQueue</span><span class='hs-layout'>,</span><span class='hs-varid'>accList</span><span class='hs-layout'>,</span><span class='hs-varid'>accCTo</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> 
<a name="line-77"></a>                                    <span class='hs-keyword'>let</span> <span class='hs-varid'>newList</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-varid'>root</span> <span class='hs-conop'>:</span> <span class='hs-varid'>accList</span><span class='hs-layout'>)</span>
<a name="line-78"></a>                                        <span class='hs-varid'>folded</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldThroughConnectedNodes</span> <span class='hs-varid'>root</span> <span class='hs-varid'>accQueue</span> <span class='hs-varid'>accCTo</span>
<a name="line-79"></a>                                    <span class='hs-keyword'>in</span> <span class='hs-layout'>(</span><span class='hs-varid'>fst</span> <span class='hs-varid'>folded</span><span class='hs-layout'>,</span> <span class='hs-varid'>newList</span><span class='hs-layout'>,</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>folded</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-80"></a>                                  <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-varid'>firstCTo</span><span class='hs-layout'>)</span> <span class='hs-varid'>queue</span>
<a name="line-81"></a>
<a name="line-82"></a><a name="foldThroughConnectedNodes"></a><span class='hs-comment'>-- | Folds through a list of vertices (used by 'foldThroughRoots' for vertices connected to a root).</span>
<a name="line-83"></a><span class='hs-comment'>-- Checks if the current vertex has any other connections other thaan the root. If it doesn't it is added to the queue. </span>
<a name="line-84"></a><span class='hs-comment'>-- Regardless of its connections the connection between it and the root is removed from the adjacency list.</span>
<a name="line-85"></a><span class='hs-definition'>foldThroughConnectedNodes</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span>                     <span class='hs-comment'>-- ^ The current root from the queue.</span>
<a name="line-86"></a>                                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>                   <span class='hs-comment'>-- ^ The current queue.</span>
<a name="line-87"></a>                                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>         <span class='hs-comment'>-- ^ The current adjacency list.</span>
<a name="line-88"></a>                                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span>  <span class='hs-comment'>-- ^ The first element is the new queue and the second element is the updated adjacency list.</span>
<a name="line-89"></a><span class='hs-definition'>foldThroughConnectedNodes</span> <span class='hs-varid'>root</span> <span class='hs-varid'>queue</span> <span class='hs-varid'>cTo</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldl</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>accQueue</span><span class='hs-layout'>,</span><span class='hs-varid'>acc2</span><span class='hs-layout'>)</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-comment'>-- b is the current node connected to root Node, acc1 is the current list, acc2 is the current adjacency list</span>
<a name="line-90"></a>                                              <span class='hs-keyword'>if</span> <span class='hs-varid'>length</span> <span class='hs-layout'>(</span><span class='hs-varid'>getEdgesTo</span> <span class='hs-varid'>b</span> <span class='hs-varid'>acc2</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;=</span> <span class='hs-num'>1</span> <span class='hs-keyword'>then</span> <span class='hs-layout'>(</span><span class='hs-varid'>accQueue</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>b</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>deleteConnection</span> <span class='hs-varid'>root</span> <span class='hs-varid'>b</span> <span class='hs-varid'>acc2</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- If the node b has no more incoming edges it is added to the list and removed from the adjacency list</span>
<a name="line-91"></a>                                              <span class='hs-keyword'>else</span> <span class='hs-layout'>(</span><span class='hs-varid'>accQueue</span><span class='hs-layout'>,</span> <span class='hs-varid'>deleteConnection</span> <span class='hs-varid'>root</span> <span class='hs-varid'>b</span> <span class='hs-varid'>acc2</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-comment'>-- Otherwise the list remains the same but it is still removed from the adjacency list</span>
<a name="line-92"></a>                                              <span class='hs-layout'>(</span><span class='hs-varid'>queue</span><span class='hs-layout'>,</span><span class='hs-varid'>cTo</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>getEdgesFrom</span> <span class='hs-varid'>root</span> <span class='hs-varid'>cTo</span><span class='hs-layout'>)</span>
<a name="line-93"></a>
<a name="line-94"></a><a name="deleteConnection"></a><span class='hs-comment'>-- | Removes a connection that goes from 'x' to 'r' in the given adjacency list </span>
<a name="line-95"></a><span class='hs-definition'>deleteConnection</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>
<a name="line-96"></a><span class='hs-definition'>deleteConnection</span> <span class='hs-varid'>x</span> <span class='hs-varid'>r</span> <span class='hs-varid'>cTo</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>r</span> <span class='hs-keyword'>then</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>delete</span> <span class='hs-varid'>x</span> <span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyword'>else</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>cTo</span>
<a name="line-97"></a>
<a name="line-98"></a><a name="dependsOn"></a><span class='hs-comment'>-- | Returns whether vertex 'a' depends on vertex 'b' by seeing if 'b' is an element in the list of edges to 'a' from 'getEdgesTo'.</span>
<a name="line-99"></a><span class='hs-definition'>dependsOn</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-100"></a><span class='hs-definition'>dependsOn</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>cTo</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>b</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>getEdgesTo</span> <span class='hs-varid'>a</span> <span class='hs-varid'>cTo</span>
<a name="line-101"></a>
<a name="line-102"></a><a name="getEdgesTo"></a><span class='hs-comment'>-- | Returns a list of edges to vertex 'a' using the provided adjacency list and the function 'getEdgesToTuple'.</span>
<a name="line-103"></a><span class='hs-definition'>getEdgesTo</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-104"></a><span class='hs-definition'>getEdgesTo</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cTo</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>isJust</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getEdgesToTuple</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cTo</span> <span class='hs-keyword'>then</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>tup</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getEdgesToTuple</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cTo</span> <span class='hs-keyword'>in</span> <span class='hs-varid'>snd</span> <span class='hs-varid'>tup</span> <span class='hs-keyword'>else</span> <span class='hs-conid'>[]</span>
<a name="line-105"></a>
<a name="line-106"></a><a name="getEdgesToTuple"></a><span class='hs-comment'>-- | Gets the element tuple from the given adjacency list as a 'Maybe' value, where the first element in the tuple is the given vertex.</span>
<a name="line-107"></a><span class='hs-definition'>getEdgesToTuple</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Maybe</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>)</span>
<a name="line-108"></a><span class='hs-definition'>getEdgesToTuple</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>find</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>x</span><span class='hs-layout'>)</span>
<a name="line-109"></a>
<a name="line-110"></a><a name="getEdgesFrom"></a><span class='hs-comment'>-- | Gives a list of vertices that the provided vertex </span>
<a name="line-111"></a><span class='hs-comment'>-- Folds over the provided adjacency list, checking if the list in the second element of each tuple contains the provided vertex and if so prepends the corrisponding verex in the first element to the list of vertices to be returned.</span>
<a name="line-112"></a><span class='hs-definition'>getEdgesFrom</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-113"></a><span class='hs-definition'>getEdgesFrom</span> <span class='hs-varid'>x</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>bs</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`elem`</span> <span class='hs-varid'>bs</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>a</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-114"></a>
<a name="line-115"></a><a name="getLevels"></a><span class='hs-comment'>-- | Takes a topologically sorted list and an adjacency list and produces a list of lists with each inner list corrisponding to the vertices in a layer.</span>
<a name="line-116"></a><span class='hs-definition'>getLevels</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>            <span class='hs-comment'>-- ^ The topologically sorted list</span>
<a name="line-117"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>            <span class='hs-comment'>-- ^ Used for recursion -- the last level generated by the function</span>
<a name="line-118"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>  <span class='hs-comment'>-- ^ The adjacency list</span>
<a name="line-119"></a>                    <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span>          <span class='hs-comment'>-- ^ The list of layers</span>
<a name="line-120"></a><span class='hs-definition'>getLevels</span> <span class='hs-conid'>[]</span> <span class='hs-keyword'>_</span> <span class='hs-keyword'>_</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>[]</span>
<a name="line-121"></a><span class='hs-definition'>getLevels</span> <span class='hs-varid'>l</span> <span class='hs-varid'>lastLevel</span> <span class='hs-varid'>cTo</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>toFold</span> <span class='hs-conop'>:</span> <span class='hs-varid'>getLevels</span> <span class='hs-layout'>(</span><span class='hs-varid'>l</span> <span class='hs-varop'>\\</span> <span class='hs-varid'>toFold</span><span class='hs-layout'>)</span> <span class='hs-varid'>toFold</span> <span class='hs-varid'>cTo</span>
<a name="line-122"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>toFold</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldLevel</span> <span class='hs-varid'>l</span> <span class='hs-varid'>lastLevel</span> <span class='hs-varid'>cTo</span>
<a name="line-123"></a>
<a name="line-124"></a><a name="foldLevel"></a><span class='hs-comment'>-- | Folds through the sorted list to produce the next sorted level of the graph.</span>
<a name="line-125"></a><span class='hs-comment'>-- For each vertex it checks if 'moveToNext' returns true, if so it skips the rest of the list and returns the new level. 'nodePosition' is used to determine where on the level to insert a vertex based on connections to the previous layer.</span>
<a name="line-126"></a><span class='hs-definition'>foldLevel</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>
<a name="line-127"></a><span class='hs-definition'>foldLevel</span> <span class='hs-varid'>l</span> <span class='hs-varid'>lastLevel</span> <span class='hs-varid'>cTo</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>let</span> <span class='hs-layout'>(</span><span class='hs-varid'>left</span><span class='hs-layout'>,</span><span class='hs-varid'>right</span><span class='hs-layout'>,</span><span class='hs-keyword'>_</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>x</span> <span class='hs-layout'>(</span><span class='hs-varid'>accL</span><span class='hs-layout'>,</span><span class='hs-varid'>accR</span><span class='hs-layout'>,</span><span class='hs-varid'>flag</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>flag</span> <span class='hs-varop'>||</span> <span class='hs-varid'>moveToNext</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cTo</span> <span class='hs-varid'>accL</span> <span class='hs-varid'>accR</span> <span class='hs-keyword'>then</span> <span class='hs-layout'>(</span><span class='hs-varid'>accL</span><span class='hs-layout'>,</span><span class='hs-varid'>accR</span><span class='hs-layout'>,</span><span class='hs-conid'>True</span><span class='hs-layout'>)</span> 
<a name="line-128"></a>                                                                               <span class='hs-keyword'>else</span> <span class='hs-keyword'>case</span> <span class='hs-varid'>nodePosition</span> <span class='hs-varid'>x</span> <span class='hs-varid'>lastLevel</span> <span class='hs-varid'>cTo</span> <span class='hs-keyword'>of</span> <span class='hs-conid'>LayerMiddle</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>accL</span> <span class='hs-varop'>++</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>x</span><span class='hs-keyglyph'>]</span><span class='hs-layout'>,</span> <span class='hs-varid'>accR</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-129"></a>                                                                                                                         <span class='hs-conid'>LayerRight</span>  <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>accL</span><span class='hs-layout'>,</span> <span class='hs-varid'>x</span> <span class='hs-conop'>:</span> <span class='hs-varid'>accR</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-130"></a>                                                                                                                         <span class='hs-conid'>LayerLeft</span>   <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-conop'>:</span><span class='hs-varid'>accL</span><span class='hs-layout'>,</span> <span class='hs-varid'>accR</span><span class='hs-layout'>,</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-131"></a>                                                 <span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-conid'>[]</span><span class='hs-layout'>,</span><span class='hs-conid'>False</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>l</span><span class='hs-layout'>)</span>
<a name="line-132"></a>                            <span class='hs-keyword'>in</span> <span class='hs-varid'>left</span> <span class='hs-varop'>++</span> <span class='hs-layout'>(</span><span class='hs-varid'>reverse</span> <span class='hs-varid'>right</span><span class='hs-layout'>)</span>
<a name="line-133"></a>
<a name="line-134"></a><a name="nodePosition"></a><span class='hs-comment'>-- | Takes a vertex and a list of vertices and an adjacency list, sees if the vertex depends on any vertices in the list and if so gives the position (left, middle or right using 'LayerPosition') of the vertex it is dependant on.</span>
<a name="line-135"></a><span class='hs-definition'>nodePosition</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LayerPosition</span>
<a name="line-136"></a><span class='hs-definition'>nodePosition</span> <span class='hs-varid'>x</span> <span class='hs-varid'>level</span> <span class='hs-varid'>cTo</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyword'>if</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span> <span class='hs-varop'>`dependsOn`</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-varid'>cTo</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>a</span> <span class='hs-varop'>`positionInGivenLayer`</span> <span class='hs-varid'>level</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-conid'>LayerMiddle</span> <span class='hs-varid'>level</span>
<a name="line-137"></a>
<a name="line-138"></a><a name="moveToNext"></a><span class='hs-comment'>-- | A boolean function which returns 'True' if the end of the currently being generated layer has been reached.</span>
<a name="line-139"></a><span class='hs-comment'>-- Checks if the current vertex depends on any of the vertices in the current layer and if any of the vertices in the layer depend on the current vertex, if so the end of the layer has been reached so 'True' is returned.</span>
<a name="line-140"></a><span class='hs-definition'>moveToNext</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Bool</span>
<a name="line-141"></a><span class='hs-definition'>moveToNext</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cTo</span> <span class='hs-varid'>accL</span> <span class='hs-varid'>accR</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>or</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>dependsOn</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-varid'>cTo</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>accL</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>or</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>dependsOn</span> <span class='hs-varid'>x</span> <span class='hs-varid'>a</span> <span class='hs-varid'>cTo</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>accR</span><span class='hs-layout'>)</span> <span class='hs-varop'>||</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>dependsOn</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cTo</span><span class='hs-layout'>)</span> <span class='hs-varid'>accL</span> <span class='hs-varop'>||</span> <span class='hs-varid'>any</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>dependsOn</span> <span class='hs-varid'>a</span> <span class='hs-varid'>x</span> <span class='hs-varid'>cTo</span><span class='hs-layout'>)</span> <span class='hs-varid'>accR</span>
<a name="line-142"></a>
<a name="line-143"></a><a name="reducedConnections"></a><span class='hs-comment'>-- | Produces a list of tuples corrisponding to connections from a given adjacency list.</span>
<a name="line-144"></a><span class='hs-definition'>reducedConnections</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>
<a name="line-145"></a><span class='hs-definition'>reducedConnections</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>y</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>x</span><span class='hs-layout'>,</span><span class='hs-varid'>y</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span> <span class='hs-varop'>++</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-146"></a>
<a name="line-147"></a><a name="positionInGivenLayer"></a><span class='hs-comment'>-- | Takes a vertex and a list of vertices (representing a layer) and returns whether the vertex is in the middle or on the left or right.</span>
<a name="line-148"></a><span class='hs-definition'>positionInGivenLayer</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>LayerPosition</span>
<a name="line-149"></a><span class='hs-definition'>positionInGivenLayer</span> <span class='hs-varid'>x</span> <span class='hs-varid'>ys</span>
<a name="line-150"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>position</span> <span class='hs-varop'>==</span> <span class='hs-varid'>midPoint</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LayerMiddle</span>
<a name="line-151"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>position</span> <span class='hs-varop'>&lt;</span> <span class='hs-varid'>midPoint</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LayerLeft</span>
<a name="line-152"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>LayerRight</span>
<a name="line-153"></a>        <span class='hs-keyword'>where</span> <span class='hs-varid'>midPoint</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromIntegral</span> <span class='hs-layout'>(</span><span class='hs-varid'>length</span> <span class='hs-varid'>ys</span> <span class='hs-comment'>-</span> <span class='hs-num'>1</span><span class='hs-layout'>)</span><span class='hs-varop'>/</span><span class='hs-num'>2</span>
<a name="line-154"></a>              <span class='hs-varid'>position</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>fromIntegral</span> <span class='hs-layout'>(</span><span class='hs-varid'>getElemIndex</span> <span class='hs-varop'>$</span> <span class='hs-varid'>x</span> <span class='hs-varop'>`elemIndex`</span> <span class='hs-varid'>ys</span><span class='hs-layout'>)</span>
<a name="line-155"></a>              <span class='hs-varid'>getElemIndex</span> <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-varid'>i</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>i</span>
<a name="line-156"></a>              <span class='hs-varid'>getElemIndex</span> <span class='hs-conid'>Nothing</span> <span class='hs-keyglyph'>=</span> <span class='hs-num'>0</span>
<a name="line-157"></a>
<a name="line-158"></a><a name="visualiseLayers"></a><span class='hs-comment'>-- | Takes the visualisation settings and a list of layers and produces a diagram.</span>
<a name="line-159"></a><span class='hs-comment'>-- Folds through the level list and calls 'draw' on each vertex to get its corrisponding diagram. The diagrams in each level are horizontally separated by the amount goverened by the 'Settings' parameter.</span>
<a name="line-160"></a><span class='hs-comment'>-- The layers themselves are then vertically separated by an amount also specified by the 'Settings' parameter. </span>
<a name="line-161"></a><span class='hs-definition'>visualiseLayers</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Draw</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Settings</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span><span class='hs-keyglyph'>]</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-162"></a><span class='hs-definition'>visualiseLayers</span> <span class='hs-varid'>s</span> <span class='hs-varid'>levelled</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>betLayerSepF</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromJust</span> <span class='hs-varop'>.</span> <span class='hs-varid'>layerSpacing</span> <span class='hs-varop'>$</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>foldl</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-varid'>acc</span> <span class='hs-varid'>level</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>center</span> <span class='hs-layout'>(</span><span class='hs-varid'>inLayerSepF</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromJust</span> <span class='hs-varop'>.</span> <span class='hs-varid'>nodeSpacing</span> <span class='hs-varop'>$</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-varop'>$</span> <span class='hs-varid'>draw</span> <span class='hs-varop'>&lt;$&gt;</span> <span class='hs-varid'>level</span><span class='hs-layout'>)</span> <span class='hs-conop'>:</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>levelled</span>
<a name="line-163"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>inLayerSepF</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>fromJust</span> <span class='hs-varop'>.</span> <span class='hs-varid'>horizontalOrientation</span> <span class='hs-varop'>$</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>vsep</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>hsep</span>
<a name="line-164"></a>          <span class='hs-varid'>betLayerSepF</span> <span class='hs-keyglyph'>=</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>fromJust</span> <span class='hs-varop'>.</span> <span class='hs-varid'>horizontalOrientation</span> <span class='hs-varop'>$</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>hsep</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>vsep</span>
<a name="line-165"></a>
<a name="line-166"></a><a name="visualiseTree"></a><span class='hs-comment'>-- | The main visualisation function.</span>
<a name="line-167"></a><span class='hs-comment'>-- Topologically sorts the list of vertices using 'getLevelList' before separating the vertices into layers by using 'levelled'.</span>
<a name="line-168"></a><span class='hs-comment'>-- A 'Diagram' is then drawn without connections, using 'visualiseLayers', and then the 'rawConnections' list is folded over and the conenctions are added one by one to produce the final diagram (which is then suurrounded by a box).</span>
<a name="line-169"></a><span class='hs-definition'>visualiseTree</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Draw</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Settings</span>        <span class='hs-comment'>-- ^ A 'Settings' type instance providing the visualisation settings for the graph.</span>
<a name="line-170"></a>                                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-varid'>a</span><span class='hs-keyglyph'>]</span>             <span class='hs-comment'>-- ^ A list of the vertices in the graph -- designed to be of the type 'Node' with a String name and a 'Diagram B' diagram attribute.</span>
<a name="line-171"></a>                                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-keyglyph'>[</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>a</span><span class='hs-layout'>)</span><span class='hs-keyglyph'>]</span>         <span class='hs-comment'>-- ^ A list of connections, with the first element being the tail and second element being the head (if the graph is 'Directed').</span>
<a name="line-172"></a>                                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>   <span class='hs-comment'>-- ^ The adjacency list for the graph.</span>
<a name="line-173"></a>                                        <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>       <span class='hs-comment'>-- ^ The 'Diagram B' of the graph visualised as a tree.</span>
<a name="line-174"></a><span class='hs-definition'>visualiseTree</span> <span class='hs-varid'>s</span> <span class='hs-varid'>nodes</span> <span class='hs-varid'>rawConnections</span> <span class='hs-varid'>connectedListWithSelfLoops</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>outDiag</span> <span class='hs-varop'>&lt;&gt;</span> <span class='hs-varid'>boundingRect</span> <span class='hs-varid'>outDiag</span>
<a name="line-175"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>outDiag</span> <span class='hs-keyglyph'>=</span> <span class='hs-layout'>(</span><span class='hs-keyword'>if</span> <span class='hs-varid'>length</span> <span class='hs-varid'>rawConnections</span> <span class='hs-varop'>&gt;</span> <span class='hs-num'>0</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>connectedDiagram</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>visualiseLayers</span> <span class='hs-varid'>s</span> <span class='hs-varid'>levelled</span><span class='hs-layout'>)</span> <span class='hs-cpp'>#</span> <span class='hs-varid'>frame</span> <span class='hs-layout'>(</span><span class='hs-varid'>fromJust</span> <span class='hs-varop'>.</span> <span class='hs-varid'>graphPadding</span> <span class='hs-varop'>$</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span>
<a name="line-176"></a>          <span class='hs-comment'>-- connectedDiagram = foldr (\(a,b) acc -&gt; connectOutside' arrowOpts1 (show a) (show b) acc) (visualiseLayers s levelled) rawConnections</span>
<a name="line-177"></a>          <span class='hs-varid'>connectedDiagram</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>foldr</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-varid'>connectVertices</span> <span class='hs-varid'>s</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>show</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-varid'>acc</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-varid'>visualiseLayers</span> <span class='hs-varid'>s</span> <span class='hs-varid'>levelled</span><span class='hs-layout'>)</span> <span class='hs-varid'>rawConnections</span>
<a name="line-178"></a>          <span class='hs-varid'>levelled</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getLevels</span> <span class='hs-varid'>topList</span> <span class='hs-conid'>[]</span> <span class='hs-varid'>connectedList</span>
<a name="line-179"></a>          <span class='hs-varid'>topList</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>nub</span> <span class='hs-varop'>$</span> <span class='hs-varid'>getLevelList</span> <span class='hs-layout'>(</span><span class='hs-varid'>getRoots</span> <span class='hs-varid'>nodes</span> <span class='hs-varid'>connectedList</span><span class='hs-layout'>)</span> <span class='hs-varid'>connectedList</span>
<a name="line-180"></a>          <span class='hs-varid'>connectedList</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>removeSelfLoops</span> <span class='hs-varid'>connectedListWithSelfLoops</span>
<a name="line-181"></a>
<a name="line-182"></a><a name="removeSelfLoops"></a><span class='hs-comment'>-- | Removes self-loops from the given 'ConnectList' to aid graph layout.</span>
<a name="line-183"></a><span class='hs-definition'>removeSelfLoops</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>ConnectList</span> <span class='hs-varid'>a</span>
<a name="line-184"></a><span class='hs-definition'>removeSelfLoops</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>map</span> <span class='hs-layout'>(</span><span class='hs-keyglyph'>\</span><span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>b</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span><span class='hs-layout'>,</span><span class='hs-varid'>delete</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span><span class='hs-layout'>)</span><span class='hs-layout'>)</span>
<a name="line-185"></a>
<a name="line-186"></a><a name="connectVertices"></a><span class='hs-comment'>-- | Connects two vertices with an arrow.</span>
<a name="line-187"></a><span class='hs-comment'>-- If the two vertex names are the same a self-loop is drawn, otherwise an arrow between the two nodes is drawn using the 'Settings' provided.</span>
<a name="line-188"></a><span class='hs-definition'>connectVertices</span> <span class='hs-keyglyph'>::</span> <span class='hs-conid'>Settings</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>String</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-189"></a><span class='hs-definition'>connectVertices</span> <span class='hs-varid'>s</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>d</span>
<a name="line-190"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>a</span> <span class='hs-varop'>==</span> <span class='hs-varid'>b</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>connectPerim'</span> <span class='hs-varid'>arrowOpts2</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-layout'>(</span><span class='hs-num'>0</span> <span class='hs-varop'>@@</span> <span class='hs-varid'>turn</span><span class='hs-layout'>)</span> <span class='hs-layout'>(</span><span class='hs-comment'>-</span><span class='hs-num'>1</span><span class='hs-varop'>/</span><span class='hs-num'>2</span> <span class='hs-varop'>@@</span> <span class='hs-varid'>turn</span><span class='hs-layout'>)</span> <span class='hs-varid'>d</span>
<a name="line-191"></a>    <span class='hs-keyglyph'>|</span> <span class='hs-varid'>otherwise</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>connectOutside'</span> <span class='hs-varid'>arrowOpts1</span> <span class='hs-varid'>a</span> <span class='hs-varid'>b</span> <span class='hs-varid'>d</span>
<a name="line-192"></a>        <span class='hs-keyword'>where</span> <span class='hs-varid'>arrowOpts1</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>with</span> <span class='hs-varop'>&amp;</span> <span class='hs-varid'>shaftStyle</span> <span class='hs-varop'>%~</span> <span class='hs-varid'>lw</span> <span class='hs-layout'>(</span><span class='hs-varid'>dynamicThick</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>directed</span> <span class='hs-varid'>s</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Directed</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>headLength</span> <span class='hs-varop'>.~</span> <span class='hs-varid'>dynamicHead</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>arrowHead</span> <span class='hs-varop'>.~</span> <span class='hs-varid'>noHead</span>
<a name="line-193"></a>              <span class='hs-varid'>arrowOpts2</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>with</span> <span class='hs-varop'>&amp;</span> <span class='hs-varid'>shaftStyle</span> <span class='hs-varop'>%~</span> <span class='hs-varid'>lw</span> <span class='hs-layout'>(</span><span class='hs-varid'>dynamicThick</span> <span class='hs-varid'>s</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;</span> <span class='hs-varid'>arrowShaft</span> <span class='hs-varop'>.~</span> <span class='hs-varid'>arc</span> <span class='hs-varid'>xDir</span> <span class='hs-layout'>(</span><span class='hs-num'>4</span><span class='hs-varop'>/</span><span class='hs-num'>6</span> <span class='hs-varop'>@@</span> <span class='hs-varid'>turn</span><span class='hs-layout'>)</span> <span class='hs-varop'>&amp;</span> <span class='hs-keyword'>if</span> <span class='hs-varid'>directed</span> <span class='hs-varid'>s</span> <span class='hs-varop'>==</span> <span class='hs-conid'>Directed</span> <span class='hs-keyword'>then</span> <span class='hs-varid'>headLength</span> <span class='hs-varop'>.~</span> <span class='hs-varid'>dynamicHead</span> <span class='hs-varid'>s</span> <span class='hs-keyword'>else</span> <span class='hs-varid'>arrowHead</span> <span class='hs-varop'>.~</span> <span class='hs-varid'>noHead</span>
<a name="line-194"></a>
<a name="line-195"></a><a name="drawTreePartialOrder"></a><span class='hs-comment'>-- | Removes indirect connections from the graph and produces a 'Diagram', using 'drawTreePartialOrder'' with the default drawing 'Settings' provided 'defaultTreeSettings'. </span>
<a name="line-196"></a><span class='hs-comment'>-- Self-loops are not supported.</span>
<a name="line-197"></a><span class='hs-definition'>drawTreePartialOrder</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Countable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-198"></a><span class='hs-definition'>drawTreePartialOrder</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>drawTreePartialOrder'</span> <span class='hs-layout'>(</span><span class='hs-varid'>defaultTreeSettings</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-varid'>drawDefaultNode</span> <span class='hs-varid'>g</span>
<a name="line-199"></a>
<a name="line-200"></a><a name="drawTreePartialOrder'"></a><span class='hs-comment'>{-| Removes indirect connections from the graph and draws it using 'visualiseTree', producing a 'Diagram'.
<a name="line-201"></a>Provides a parameter to supply an instance of the 'Settings' type that will give the drawing functions the graph visualisation settings.
<a name="line-202"></a>An example is the output of the 'defaultTreeSettings' function:
<a name="line-203"></a>@
<a name="line-204"></a>defaultTreeSettings :: (Countable a) =&gt; Graph a -&gt; Settings
<a name="line-205"></a>defaultTreeSettings g = Settings (dynamicStyle small $ count g) 
<a name="line-206"></a>                                 (dynamicStyle thin $ count g) 
<a name="line-207"></a>                                 Directed 
<a name="line-208"></a>                                 False
<a name="line-209"></a>                                 (Just 0.2) 
<a name="line-210"></a>                                 (Just 0.3) 
<a name="line-211"></a>                                 (Just 0.1) 
<a name="line-212"></a>                                 Nothing 
<a name="line-213"></a>                                 Nothing 
<a name="line-214"></a>                                 Nothing
<a name="line-215"></a>@
<a name="line-216"></a>This shows that the arrow head size, arrow shaft thickness, whether the graph is directed, whether the graph is horizontally orientated, the horizontal and vertical spacing between vertices and the graph frame padding can be customised.
<a name="line-217"></a>
<a name="line-218"></a>The indirect conenctions are removed by using 'reduction' and the graph is processed by 'getVertices' to produce a 'ProcessedGraph' instance containing the vertices and their connections.
<a name="line-219"></a>Self-loops are not supported.
<a name="line-220"></a>-}</span>
<a name="line-221"></a><span class='hs-definition'>drawTreePartialOrder'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Countable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Settings</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-222"></a><span class='hs-definition'>drawTreePartialOrder'</span> <span class='hs-varid'>s</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>visualiseTree</span> <span class='hs-varid'>s</span> <span class='hs-varid'>nodes</span> <span class='hs-varid'>newConnections</span> <span class='hs-varid'>reduced</span>
<a name="line-223"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>newConnections</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reducedConnections</span> <span class='hs-varid'>reduced</span>
<a name="line-224"></a>          <span class='hs-varid'>reduced</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>reduction</span> <span class='hs-layout'>(</span><span class='hs-varid'>connectedTo</span> <span class='hs-varid'>connections</span><span class='hs-layout'>)</span> <span class='hs-conid'>[]</span>
<a name="line-225"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>ProcessedGraph</span> <span class='hs-varid'>nodes</span> <span class='hs-varid'>connections</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getVertices</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>g</span>
<a name="line-226"></a>
<a name="line-227"></a><a name="drawTree"></a><span class='hs-comment'>-- | Draws the provided graph as a tree, producing a 'Diagram' using 'drawTree'', using the default settings. Self-loops are supported.</span>
<a name="line-228"></a><span class='hs-definition'>drawTree</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Countable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-229"></a><span class='hs-definition'>drawTree</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>drawTree'</span> <span class='hs-layout'>(</span><span class='hs-varid'>defaultTreeSettings</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span> <span class='hs-varid'>drawDefaultNode</span> <span class='hs-varid'>g</span>
<a name="line-230"></a>
<a name="line-231"></a><a name="drawTree'"></a><span class='hs-comment'>-- | Draws the graph provided with 'visualiseTree', using the provided visualisation 'Settings'.</span>
<a name="line-232"></a><span class='hs-comment'>-- Uses 'getVertices' to produce a 'ProcessedGraph' with the graph's verices and conenctions, then uses 'visualiseTree' with these, self-loops are supported.</span>
<a name="line-233"></a><span class='hs-definition'>drawTree'</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Show</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Eq</span> <span class='hs-varid'>a</span><span class='hs-layout'>,</span> <span class='hs-conid'>Countable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Settings</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-layout'>(</span><span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Diagram</span> <span class='hs-conid'>B</span>
<a name="line-234"></a><span class='hs-definition'>drawTree'</span> <span class='hs-varid'>s</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>visualiseTree</span> <span class='hs-varid'>s</span> <span class='hs-varid'>nodes</span> <span class='hs-varid'>connections</span> <span class='hs-varid'>connectedList</span>
<a name="line-235"></a>    <span class='hs-keyword'>where</span> <span class='hs-varid'>connectedList</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>connectedTo</span> <span class='hs-varid'>connections</span>
<a name="line-236"></a>          <span class='hs-layout'>(</span><span class='hs-conid'>ProcessedGraph</span> <span class='hs-varid'>nodes</span> <span class='hs-varid'>connections</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=</span> <span class='hs-varid'>getVertices</span> <span class='hs-varid'>drawF</span> <span class='hs-varid'>g</span>
<a name="line-237"></a>
<a name="line-238"></a><a name="defaultTreeSettings"></a><span class='hs-comment'>-- | Generates a default 'Settings' from the provided graph.</span>
<a name="line-239"></a><span class='hs-comment'>-- The arrow head size and shaft thickness vary in accordance with the graph size and the graph is 'Directed'and vertically orientated with layer separation, vertex (horizonal) separation and frame padding of 0.2, 0.3 and 0.1 respectively. </span>
<a name="line-240"></a><span class='hs-definition'>defaultTreeSettings</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Countable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Settings</span>
<a name="line-241"></a><span class='hs-definition'>defaultTreeSettings</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Settings</span> <span class='hs-layout'>(</span><span class='hs-varid'>dynamicStyle</span> <span class='hs-varid'>small</span> <span class='hs-varop'>$</span> <span class='hs-varid'>count</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-242"></a>                                 <span class='hs-layout'>(</span><span class='hs-varid'>dynamicStyle</span> <span class='hs-varid'>thin</span> <span class='hs-varop'>$</span> <span class='hs-varid'>count</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-243"></a>                                 <span class='hs-conid'>Directed</span>
<a name="line-244"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-conid'>False</span><span class='hs-layout'>)</span>
<a name="line-245"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-num'>0.2</span><span class='hs-layout'>)</span>
<a name="line-246"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-num'>0.3</span><span class='hs-layout'>)</span>
<a name="line-247"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-num'>0.1</span><span class='hs-layout'>)</span>
<a name="line-248"></a>                                 <span class='hs-conid'>Nothing</span>
<a name="line-249"></a>                                 <span class='hs-conid'>Nothing</span>
<a name="line-250"></a>                                 <span class='hs-conid'>Nothing</span>
<a name="line-251"></a>
<a name="line-252"></a><a name="defaultTreeSettingsHorizontal"></a><span class='hs-comment'>-- | Generates a default 'Settings' from the provided graph, but rotated so the graph is horizonal instead of vertical.</span>
<a name="line-253"></a><span class='hs-comment'>-- The arrow head suze and shaft thickness vary in accordance with the graph size and the graph is 'Directed' and horizontally orientated with layer separation, vertex (horizonal) separation and frame padding of 0.2, 0.3 and 0.1 respectively. </span>
<a name="line-254"></a><span class='hs-definition'>defaultTreeSettingsHorizontal</span> <span class='hs-keyglyph'>::</span> <span class='hs-layout'>(</span><span class='hs-conid'>Countable</span> <span class='hs-varid'>a</span><span class='hs-layout'>)</span> <span class='hs-keyglyph'>=&gt;</span> <span class='hs-conid'>Graph</span> <span class='hs-varid'>a</span> <span class='hs-keyglyph'>-&gt;</span> <span class='hs-conid'>Settings</span>
<a name="line-255"></a><span class='hs-definition'>defaultTreeSettingsHorizontal</span> <span class='hs-varid'>g</span> <span class='hs-keyglyph'>=</span> <span class='hs-conid'>Settings</span> <span class='hs-layout'>(</span><span class='hs-varid'>dynamicStyle</span> <span class='hs-varid'>small</span> <span class='hs-varop'>$</span> <span class='hs-varid'>count</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-256"></a>                                 <span class='hs-layout'>(</span><span class='hs-varid'>dynamicStyle</span> <span class='hs-varid'>thin</span> <span class='hs-varop'>$</span> <span class='hs-varid'>count</span> <span class='hs-varid'>g</span><span class='hs-layout'>)</span>
<a name="line-257"></a>                                 <span class='hs-conid'>Directed</span>
<a name="line-258"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-conid'>True</span><span class='hs-layout'>)</span>
<a name="line-259"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-num'>0.2</span><span class='hs-layout'>)</span>
<a name="line-260"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-num'>0.3</span><span class='hs-layout'>)</span>
<a name="line-261"></a>                                 <span class='hs-layout'>(</span><span class='hs-conid'>Just</span> <span class='hs-num'>0.1</span><span class='hs-layout'>)</span>
<a name="line-262"></a>                                 <span class='hs-conid'>Nothing</span>
<a name="line-263"></a>                                 <span class='hs-conid'>Nothing</span>
<a name="line-264"></a>                                 <span class='hs-conid'>Nothing</span>
</pre></body>
</html>
